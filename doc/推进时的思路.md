
# 推进时的思路

## 错误一：autogen.sh

执行autogen.sh时出现如下错误

```log
configure: error: Unsupported host_cpu riscv64 for host_os linux-gnu
Error running configure at ./autogen.sh line 322.
```

### 错误是在哪个文件生成的？

查看./autogen.sh，该文件由perl写成，322行是一个很长的else的结尾，没什么信息，先放着

Unsupported host_cpu这一部分应该是固定不变的，所以在libreoffice源代码文件夹里搜索，发现在configure.ac（和configure文件）里，查阅这两个文件的关系，发现如下：

```plain
src --autoscan--> configure.scan --edit--> configure.ac
configure.a--aclocal--> aclocal.m4
configure.ac + aclocal.m4 --autoconf--> configure
configure.ac --autoheader--> config.h.in
```

回过头来./autogen.sh那个else部分，检索configure与autoconf，这样可以推断./autogen.sh调用autoconf从configure.ac文件生成configure文件，然后执行configure
那么问题应该先从configure.ac开始排查

### 错误是在文件的哪个部分生成的？

configure.ac里有13处

```shell
AC_MSG_ERROR([Unsupported host_cpu $host_cpu for host_os $host_os])
```

尝试了一种笨方法，把这13处输出都修成不一样的，然后再运行autogen.sh，报错

```log
configure: error: 08 Unsupported host_cpu riscv64 for host_os linux-gnu
```

在configure.ac第8处，第5213行
溯源，找到第一层case：

```shell
case "$host_cpu" in #5102
...
*)
  AC_MSG_ERROR([08 Unsupported host_cpu $host_cpu for host_os $host_os]) ##5213
```

继续溯源，找到第二层case

```shell
case "$host_os" in #4920
...
linux-gnu*|linux-musl*) #5096
```

这段代码意味着，先查到host_os是linux，然后再查host_cpu，查不到riscv64，所以只能跳转到默认情况，然后报错

### 尝试添加riscv参数

模仿mips64相关代码插入如下部分

```shell
riscv64)
  CPUNAME=RISCV64
  RTL_ARCH=RISCV64
  EPM_FLAGS="-a riscv64"
  PLATFORMID=linux_riscv64
  ;;
```

MARK：问题：为什么这么写？mips_el什么的为什么后面有后缀呢？
再autoten.sh一下，看报错

```log
configure: WARNING: You are building 32-bit binaries but the JDK  is 64-bit
configure: error: You should pass the --with-jdk-home option pointing to a (32-bit) JDK
```

### 解决JDK报错问题

搜索You are building 32-bit binaries but the JDK，只有两处 #8544 #8562

继续用刚才修改报错输出的土办法，定位到 #8562

这一部分的代码

```shell
elif test "$cross_compiling" != "yes"; then
         case $CPUNAME in
             AARCH64|AXP|X86_64|HPPA|IA64|POWERPC64|S390X|SPARC64|GODSON64)
                 if test -f "$JAVAINTERPRETER" -a "$JAVAINTERPRETER -version 2>&1 | $GREP -i 64-bit" = "" >/dev/null; then
                     AC_MSG_WARN([You are building 64-bit binaries but the JDK $JAVAINTERPRETER is 32-bit])
                     AC_MSG_ERROR([You should pass the --with-jdk-home option pointing to a 64-bit JDK])
                 fi
                 ;;
             *) # assumption: everything else 32-bit
                 if test -f "$JAVAINTERPRETER" -a "$JAVAINTERPRETER -version 2>&1 | $GREP -i 64-bit" != ""  >/dev/null; then
                     AC_MSG_WARN([02 You are building 32-bit binaries but the JDK $howfound is 64-bit])
                     AC_MSG_ERROR([You should pass the --with-jdk-home option pointing to a (32-bit) JDK])
                 fi
                 ;;
         esac
```

观察上述代码，可以确定的事实有

1. 这不是交叉编译（cross_compiling）
2. 没有找到CPUNAME
3. 以下的判断语句是true的

```shell
test -f "$JAVAINTERPRETER" -a "`$JAVAINTERPRETER -version 2>&1 | $GREP -i 64-bit`" != "" #8561
```

可以看到，如果修改了CPUNAME的判断条件，进入上一个分支，那么这个报错就不会出现
那么添加一个RISCV64进去吧

```plain
AARCH64|AXP|X86_64|HPPA|IA64|POWERPC64|S390X|SPARC64|GODSON64|RISCV64) #8554
```

./autogen.sh**成功通过**

### 其他问题

于波老师在[https://github.com/yuzibo/debian_dev/blob/main/0004-libreoffice-add_support_riscv64.diff](https://github.com/yuzibo/debian_dev/blob/main/0004-libreoffice-add_support_riscv64.diff)里也修改了configure.ac文件的这一部分

```shell
# This is only used in Qt5/Qt6/KF5 checks to determine if /usr/lib64
# paths should be added to library search path. So lets put all 64-bit
# platforms there.
supports_multilib=
case "$host_cpu" in
x86_64 | powerpc64 | powerpc64le | s390x | aarch64 | mips64 | mips64el)
    if test "$SAL_TYPES_SIZEOFLONG" = "8"; then
        supports_multilib="yes"
    fi
    ;;
*)
    ;;
esac
```

虽然现在的环境里是没有/usr/lib64的，但是加上看起来也无伤大雅（只是增加了lib的搜索路径）

## 错误二：gb_UnoApiHeadersTarget_select_variant

```log
mkdir -p /home/infinity/libreoffice/instdir
/home/infinity/libreoffice/solenv/bin/install-gdb-printers -a /home/infinity/libreoffice/instdir -c
make -j 2  -rs -f /home/infinity/libreoffice/Makefile.gbuild build  
/home/infinity/libreoffice/solenv/gbuild/UnoApiTarget.mk:127: *** gb_UnoApiHeadersTarget_select_variant must be defined by platform.  Stop.
make: *** [Makefile:288: build] Error 2
```

其中，`gb_UnoApiHeadersTarget_select_variant must be defined by platform`是标红加粗的

### 定位错误

查看`UnoApiTarget.mk`#127

```makefile
ifeq ($(origin gb_UnoApiHeadersTarget_select_variant),undefined)
$(eval $(call gb_Output_error,gb_UnoApiHeadersTarget_select_variant must be defined by platform))
endif
```

`gb_UnoApiHeadersTarget_select_variant`并不是在这里定义的
检查这个变量的定义位置，有六个文件

```plain
com_MSC_class.mk
EMSCRIPTEN_INTEL_GCC.mk
IOS.mk
macosx.mk
solaris.mk
unxgcc.mk
```

这六个文件，都有相同的一段代码

```makefile
ifeq ($(DISABLE_DYNLOADING),TRUE)
gb_UnoApiHeadersTarget_select_variant = $(if $(filter udkapi,$(1)),comprehensive,$(2))
else
gb_UnoApiHeadersTarget_select_variant = $(2)
endif
```

尝试在这六段代码中都插入$(call gb_Output_error,shit)来定位错误，并没有发现输出
陷入苦恼……

### 另辟蹊径

不过仔细观察一下这六个文件所在的目录：solenv/gbuild/platform，这个文件夹里存放了大量的基于不同系统、不同架构的.mk文件，是不是和RISCV64缺失有关呢？

观察LINUX_X86_64_GCC.mk等文件，发现都包括了这样一行

```makefile
include $(GBUILDDIR)/platform/linux.mk
```

探查linux.mk，里面都有这样一行

```makefile
include $(GBUILDDIR)/platform/unxgcc.mk
```

也就是说是这么一个关系：

`LINUX_X86_64_GCC --> linux.mk --> unxgcc.mk`

上一节里`unxgcc.mk`并未被执行，那么是不是`linux.mk`也未被执行呢？那么在`linux.mk`里也插入`$(call gb_Output_error,shit)`，make没有输出，说明`linux.mk`也未被执行

那么试着创建`LINUX_RISCV64_GCC.mk`，把linux.mk包括进去，linux.mk被执行了！

进一步确认unxgcc.mk里的内容，执行了gb_UnoApiHeadersTarget_select_variant = $(2)，说明$(DISABLE_DYNLOADING) ≠ TRUE

这里有个疑问，LINUX_GODSON64_GCC.mk以及LINUX_POWERPC_GCC.mk里有如下两行代码

```plain
gb_CPUDEFS += -DMIPS64
gb_CPUDEFS += -DPPC
```

我不清楚应该查询什么手册，GCC v11.3.0里也没有检索到DPPC的字样，所以我到底应该查什么手册呢？

至此，gb_UnoApiHeadersTarget_select_variant错误就告一段落了，又有了新的报错 ↓

## 错误三：*no bridge selected for build:*

### bailing out

```log
/home/infinity/libreoffice//bridges/Module_bridges.mk:27: *** no bridge selected for build: bailing out.  Stop.
make: *** [Makefile:288: build] Error 2
```

### 定位`no bridge selected for build`错误

错误出处

```makefile
# <root_lo>/bridges/Module_bridges.mk
ifeq (,$(filter build,$(gb_Module_SKIPTARGETS))) 
ifeq ($(strip $(bridges_SELECTED_BRIDGE)),)
$(call gb_Output_error,no bridge selected for build: bailing out) #27
else ifneq ($(words $(bridges_SELECTED_BRIDGE)),1)
$(call gb_Output_error,multiple bridges selected for build: $(bridges_SELECTED_BRIDGE))
endif
endif
```

可以看到，判断了两个条件是否为空，这两个条件是

1. `$(filter build,$(gb_Module_SKIPTARGETS))`，这个的意思是仅保留`gb_Module_SKIPTARGETS`变量中的`build`
2. `$(strip $(bridges_SELECTED_BRIDGE))`，这个的意思是去掉`bridges_SELECTED_BRIDGE`的空格

也就是说，`gb_Module_SKIPTARGETS`中没有`build`，`bridges_SELECTED_BRIDGE`是空的，导致`no bridge selected for build: bailing out`错误，那么应该分头查找这两项

#### gb_Module_SKIPTARGETS

gb_Module_SKIPTARGETS定义自文件post_SpeedUpTargets.mk，通过使用gb_Output_error测试，定位到如下代码

```makefile
# post_SpeedUpTartgets.mk
ifeq (,$(filter perfcheck,$(MAKECMDGOALS)))
gb_Module_SKIPTARGETS += perfcheck #这一行 #24
else
...
```

即，`gb_Module_SKIPTARGETS=perfcheck`，这个变量没有`build`

#### bridges_SELECTED_BRIDGE

`gb_Module_SKIPTARGETS`定义自文件`Library_cpp_uno.mk`，检索发现如下内容

```plain
...
96,1: bridges_SELECTED_BRIDGE := gcc3_linux_m68k
103,1: bridges_SELECTED_BRIDGE := gcc3_linux_mips
111,1: bridges_SELECTED_BRIDGE := gcc3_linux_mips64
120,1: bridges_SELECTED_BRIDGE := gcc3_linux_powerpc
124,1: bridges_SELECTED_BRIDGE := gcc3_aix_powerpc
...
```

欸，熟悉的不同平台不同架构，拎出mips64部分的代码来

```makefile
#Library_cpp_uno.mk
#108
else ifeq ($(CPUNAME),GODSON64)
ifneq ($(filter LINUX,$(OS)),)
bridges_SELECTED_BRIDGE := gcc3_linux_mips64
bridge_asm_objects := call
bridge_noopt_objects := cpp2uno uno2cpp
bridge_exception_objects := except
endif
```

尝试加入以下代码

```makefile
#117
else ifeq ($(CPUNAME),RISCV64)
ifneq ($(filter LINUX,$(OS)),)
bridges_SELECTED_BRIDGE := gcc3_linux_riscv64
bridge_asm_objects := call
bridge_noopt_objects := cpp2uno uno2cpp
bridge_exception_objects := except
endif
```

新的报错：

```plain
/home/infinity/libreoffice/bridges/Library_cpp_uno.mk:254: *** No such source file /home/infinity/libreoffice/bridges/source/cpp_uno/gcc3_linux_riscv64/except.cxx.  Stop.
```

### 应该添加什么文件？

查看`/home/infinity/libreoffice/bridges/source/cpp_uno/`目录

```plain
gcc3_aix_powerpc/    gcc3_linux_mips/       gcc3_macosx_x86-64/
gcc3_ios/            gcc3_linux_mips64/     gcc3_solaris_intel/
gcc3_linux_aarch64/  gcc3_linux_powerpc/    gcc3_solaris_sparc/
gcc3_linux_alpha/    gcc3_linux_powerpc64/  gcc3_wasm/
gcc3_linux_arm/      gcc3_linux_s390/       msvc_shared/
gcc3_linux_hppa/     gcc3_linux_s390x/      msvc_win32_arm64/
gcc3_linux_ia64/     gcc3_linux_sparc/      msvc_win32_intel/
gcc3_linux_intel/    gcc3_linux_sparc64/    msvc_win32_x86-64/
gcc3_linux_m68k/     gcc3_linux_x86-64/     shared/
```

然后查看`gcc3_linux_mips64`**文件夹**：

```plain
call.hxx  call.s  cpp2uno.cxx  except.cxx  share.hxx  uno2cpp.cxx
```

联想到上文

```makefile
#Library_cpp_uno.mk
#108
bridges_SELECTED_BRIDGE := gcc3_linux_mips64
bridge_asm_objects := call
bridge_noopt_objects := cpp2uno uno2cpp
bridge_exception_objects := except
```

可以猜测，`bridges_SELECTED_BRIDGE`指定的是文件夹，而后面三个则指定了具体的文件，那么应该尝试将`mips64`的文件夹复制一份为`gcc3_linux_riscv64`

core竟然开始编译了！

关于加速编译过程，可以参看“小技巧”一文

## 错误四：firebird3

错误日志`https://github.com/Sakura286/TmpShare/blob/main/20220615-172432-lo.log`

firebird3是种**数据库**

检索firebird官网发现只提供了x86与ARM架构的程序；另一方面libreoffice对firebird有替代品（我又忘了来源了），那么在“最小子集化”编译的时候暂时禁掉无妨

`autogen.sh --help`，并在产生的结果检索`firebird`，找到了`--disable-firebird-sdbc`参数，试着autogen添加这个参数，然后推进到错误五

## 错误五：jvmfwk

错误日志`https://github.com/Sakura286/TmpShare/blob/main/2206156-140242-lo.log`

基本上都是下面两个文件的错误：

```plain
<lo_root>/jvmfwk/plugins/sunmajor/pluginlib/otherjre.cxx
<lo_root>/jvmfwk/plugins/sunmajor/pluginlib/sunjre
```

部分错误

```log
In file included from /home/infinity/libreoffice/jvmfwk/plugins/sunmajor/pluginlib/otherjre.hxx:23,
                 from /home/infinity/libreoffice/jvmfwk/plugins/sunmajor/pluginlib/otherjre.cxx:21:
/home/infinity/libreoffice/jvmfwk/inc/vendorbase.hxx:79:2: error: #error unknown platform
   79 | #error unknown platform
      |  ^~~~~
```

`otherjre.cxx`的第21行是这样

```cpp
#include "otherjre.hxx"
```

所以继续找otherjre.hxx的第23行：

```cpp
#include <vendorbase.hxx>
```

继续找`<lo_root>/jvmfwk/inc/vendorbase.hxx`第79行

```cpp
...
#define JFW_PLUGIN_ARCH "parisc"
#elif defined AXP
#define JFW_PLUGIN_ARCH "alpha"
#elif defined AARCH64
#define JFW_PLUGIN_ARCH "aarch64"
#else // SPARC, INTEL, POWERPC, MIPS, MIPS64, ARM, IA64, M68K, HPPA, ALPHA
#error unknown platform
#endif
...
```

在#62插入

```cpp
#elif defined RISCV64
#define JFW_PLUGIN_ARCH "riscv64"
```

然后就通过了……真莫名其妙啊，炼丹似的

## 错误六：cpp_uno

错误日志`https://github.com/Sakura286/TmpShare/blob/main/20220616-145237-lo.log`

使用于波老师的patch

手动看了一下和之前的修改的区别

- `call.s`改动比较多，主要是把变量名与指令改成了riscv64相同的
- `cpp2uno.cxx`两处改动

```cpp
# cpp2uno.cxx
# 46
//#ifndef ANDROID
//#include <sys/sysmips.h>
//#endif

# cppuno.cxx
# 610
#ifdef ANDROID
  (void) bptr;
  (void) eptr;
```

- uno2cpp.cxx改动了变量名
  
patch后，出现了新的错误

[https://github.com/Sakura286/TmpShare/blob/main/20220616-162240-lo.log](https://github.com/Sakura286/TmpShare/blob/main/20220616-162240-lo.log)

[https://github.com/Sakura286/TmpShare/blob/main/20220616-163412-lo.log](https://github.com/Sakura286/TmpShare/blob/main/20220616-163412-lo.log)

### 定位`cpp_uno`错误

错误内容的开头

```log
/home/infinity/libreoffice/bridges/source/cpp_uno/gcc3_linux_riscv64/call.s: Assembler messages:
/home/infinity/libreoffice/bridges/source/cpp_uno/gcc3_linux_riscv64/call.s:61: Error: illegal operands `mv a1,0(ra)'
/home/infinity/libreoffice/bridges/source/cpp_uno/gcc3_linux_riscv64/call.s:82: Error: unrecognized opcode `b .Lfinish'
/tmp/ccmCpgbR.s: Error: open CFI at the end of file; missing .cfi_endproc directive
```

看起来是汇编那边出了问题

## 错误七：galleries

错误内容

```log
Illegal instruction
make[1]: *** [/home/infinity/libreoffice/solenv/gbuild/Gallery.mk:57: /home/infinity/libreoffice/workdir/Gallery/backgrounds.done] Error 1
make[1]: *** Waiting for unfinished jobs....
Illegal instruction
make[1]: *** [/home/infinity/libreoffice/solenv/gbuild/Gallery.mk:57: /home/infinity/libreoffice/workdir/Gallery/sounds.done] Error 1
make: *** [Makefile:288: build] Error 2
```

使用`--with-galleries=no`选项

## 错误八：make check错误

错误内容

```log
[CUT] dbaccess_dialog_save
Illegal instruction
[_RUN_____] DialogSaveTest::test

No core file identified in directory /home/infinity/libreoffice/workdir/CppunitTest/dbaccess_dialog_save.test.core
To show backtraces for crashes during test execution,
enable core files with:

   ulimit -c unlimited


Error: a unit test failed, please do one of:

make CppunitTest_dbaccess_dialog_save CPPUNITTRACE="gdb --args"
    # for interactive debugging on Linux
make CppunitTest_dbaccess_dialog_save VALGRIND=memcheck
    # for memory checking
make CppunitTest_dbaccess_dialog_save DEBUGCPPUNIT=TRUE
    # for exception catching

You can limit the execution to just one particular test by:

make CPPUNIT_TEST_NAME="testXYZ" ...above mentioned params...

make[1]: *** [/home/infinity/libreoffice/solenv/gbuild/CppunitTest.mk:121: /home/infinity/libreoffice/workdir/CppunitTest/dbaccess_dialog_save.test] Error 1
make: *** [Makefile:288: build] Error 2
```

使用`ulimit -c unlimited`后出现如下错误

```log
[CUT] dbaccess_dialog_save
Illegal instruction (core dumped)
[_RUN_____] DialogSaveTest::test
/home/infinity/libreoffice/solenv/bin/gdb-core-bt.sh: 23: file: not found

It looks like /home/infinity/libreoffice/workdir/LinkTarget/Executable/cppunittester generated /home/infinity/libreoffice/workdir/CppunitTest/dbaccess_dialog_save.test.core/core
Backtraces:
<frozen importlib._bootstrap>:914: ImportWarning: GdbRemoveReadlineFinder.find_spec() not found; falling back to find_module()

warning: Can't open file /usr/bin/qemu-riscv64-static during file-backed mapping note processing

warning: core file may not match specified executable file.

warning: Couldn't find general-purpose registers in core file.

warning: Unexpected size of section `.reg2' in core file.
Core was generated by `/usr/libexec/qemu-binfmt/riscv64-binfmt-P /home/infinity/libreoffice/workdir/Li'.

warning: Couldn't find general-purpose registers in core file.

warning: Unexpected size of section `.reg2' in core file.
#0  <unavailable> in ?? ()
ra             <unavailable>
sp             <unavailable>
gp             <unavailable>
tp             <unavailable>
t0             <unavailable>
t1             <unavailable>
t2             <unavailable>
fp             <unavailable>
s1             <unavailable>
a0             <unavailable>
a1             <unavailable>
a2             <unavailable>
a3             <unavailable>
a4             <unavailable>
a5             <unavailable>
a6             <unavailable>
a7             <unavailable>
s2             <unavailable>
s3             <unavailable>
s4             <unavailable>
s5             <unavailable>
s6             <unavailable>
s7             <unavailable>
s8             <unavailable>
s9             <unavailable>
s10            <unavailable>
s11            <unavailable>
t3             <unavailable>
t4             <unavailable>
t5             <unavailable>
t6             <unavailable>
pc             <unavailable>

Thread 1 (process 1):
#0  <unavailable> in ?? ()
PC unavailable, cannot determine locals.


Error: a unit test failed, please do one of:

make CppunitTest_dbaccess_dialog_save CPPUNITTRACE="gdb --args"
    # for interactive debugging on Linux
make CppunitTest_dbaccess_dialog_save VALGRIND=memcheck
    # for memory checking
make CppunitTest_dbaccess_dialog_save DEBUGCPPUNIT=TRUE
    # for exception catching

You can limit the execution to just one particular test by:

make CPPUNIT_TEST_NAME="testXYZ" ...above mentioned params...

make[1]: *** [/home/infinity/libreoffice/solenv/gbuild/CppunitTest.mk:121: /home/infinity/libreoffice/workdir/CppunitTest/dbaccess_dialog_save.test] Error 1
make: *** [Makefile:288: build] Error 2
```

### 处理dbaccess_dialog_save报错

检查 dbaccess - Database access tools, for base database application

定位<lo_root>/dbaccess/Module_dbaccess.mk

错误逐步处理：

#### qemu-riscv64-static

提示`warning: Can't open file /usr/bin/qemu-riscv64-static during file-backed mapping note processing`

使用[Command-not-found](https://command-not-found.com/qemu-riscv64-static)查看`qemu-riscv64-static`，得到需要使用apt安装`qemu-user-static`

安装后该条错误消失

#### warning: core file may not match specified executable file

为什么？明明是rv64环境？而且之前装qemu是为了什么？

我是不是可以在x86环境下调试这个core试试呢？

在外部使用`gdb -c <core>`后出现了一大堆错误……

不过这个启发了我：这个究竟是个什么文件呢？`file <core>`一下之后，出现如下提示：

```log
/home/infinity/libreoffice/workdir/CppunitTest/dbaccess_dialog_save.test.core/core: ELF 64-bit LSB core file, x86-64, version 1 (SYSV), SVR4-style, from '/usr/libexec/qemu-binfmt/riscv64-binfmt-P /home/infinity/libreoffice/workdir/Li', real uid: 1000, effective uid: 1000, real gid: 1000, effective gid: 1000, execfn: '/home/infinity/libreoffice/workdir/LinkTarget/Executable/cppunittester', platform: 'x86_64'
```

坏了，x86-64？去检查一下`<lo_root>/workdir/LinkTarget/Executable/cppunittester`这个文件

```log
$ file cppunittester
cppunittester: ELF 64-bit LSB pie executable, UCB RISC-V, RVC, double-float ABI, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux-riscv64-lp64d.so.1, BuildID[sha1]=b066245fee88bc6ecf0118d829d46db4ce3e5fbf, for GNU/Linux 4.15.0, not stripped
```

> 附注：如果要使用hexdump (-C)命令查看二进制内容的话，通过apt安装bsdmainutils

.ELF指的是Executable and Linkable Format，可执行可链接格式，linux与unix的二进制可执行文件

gcc-riscv64-linux-gnu

现在的问题是core dump，但是dump出来的文件是x86-64的，在rv64环境下调试只能出现

```log
#0  <unavailable> in ?? ()
```

在外部的x86-64环境下调试，会出现

```log
#0  0x000000000066110a in ?? ()
#1  0x000000003aa0070b in ?? ()
#2  0x00007ffd62e01ec8 in ?? ()
#3  0x0000000000000004 in ?? ()
#4  0x00000000004e78cd in ?? ()
#5  0x00007ff3fae39d80 in ?? ()
#6  0x000000000069cae2 in ?? ()
#7  0x0000000000000000 in ?? ()
```

接下来很可能要处理这些乱码问题，但是我仍然有两个想法

1. 是不是 make check 启动的时候需要添加一些架构相关的参数？
2. 是不是 uno 如果是 uno

#### make CppunitTest_dbaccess_dialog_save CPPUNITTRACE="gdb --args"

报错

```log
warning: Could not trace the inferior process.
warning: ptrace: Function not implemented
During startup program exited with code 127.
```

查阅资料，参考`https://stackoverflow.com/questions/70977408/docker-arm32-gdb-ptrace-could-not-trace-the-inferior-process`

> QEMU's user-mode emulation does not support the ptrace system call, which means you can't run a gdb inside a chroot or container that is using QEMU to emulate each process and connect to an emulated process.
> If you need to debug something that's running inside QEMU, you can instead enable QEMU's builtin gdbstub, and connect a target-architecture aware gdb running on your host system to it.

意思是，使用qemu实现的chroot里无法使用gdb，应该使用gdbstub

然而apt里没有gdbstub，查阅[QEMU官方wiki](https://wiki.qemu.org/Features/gdbstub)
