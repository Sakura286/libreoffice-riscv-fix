
# 推进时的思路

## 错误一：autogen.sh

执行autogen.sh时出现如下错误

```log
configure: error: Unsupported host_cpu riscv64 for host_os linux-gnu
Error running configure at ./autogen.sh line 322.
```

## 错误是在哪个文件生成的？

查看./autogen.sh，该文件由perl写成，322行是一个很长的else的结尾，没什么信息，先放着

Unsupported host_cpu这一部分应该是固定不变的，所以在libreoffice源代码文件夹里搜索，发现在configure.ac（和configure文件）里，查阅这两个文件的关系，发现如下：

```plain
src --autoscan--> configure.scan --edit--> configure.ac

configure.a--aclocal--> aclocal.m4
configure.ac + aclocal.m4 --autoconf--> configure
configure.ac --autoheader--> config.h.in
```
回过头来./autogen.sh那个else部分，检索configure与autoconf，这样可以推断./autogen.sh调用autoconf从configure.ac文件生成configure文件，然后执行configure
那么问题应该先从configure.ac开始排查

## 错误是在文件的哪个部分生成的？

configure.ac里有13处

```plain
AC_MSG_ERROR([Unsupported host_cpu $host_cpu for host_os $host_os])
```
尝试了一种笨方法，把这13处输出都修成不一样的，然后再运行autogen.sh，报错
```plain
configure: error: 08 Unsupported host_cpu riscv64 for host_os linux-gnu
```
在configure.ac第8处，第5213行
溯源，找到第一层case：

```plain
case "$host_cpu" in #5102
...
*)
  AC_MSG_ERROR([08 Unsupported host_cpu $host_cpu for host_os $host_os]) ##5213
```
继续溯源，找到第二层case
```plain
case "$host_os" in #4920
...
linux-gnu*|linux-musl*) #5096
```
这段代码意味着，先查到host_os是linux，然后再查host_cpu，查不到riscv64，所以只能跳转到默认情况，然后报错
## 尝试添加riscv参数

模仿mips64相关代码插入如下部分

```plain
riscv64)
  CPUNAME=RISCV64
  RTL_ARCH=RISCV64
  EPM_FLAGS="-a riscv64"
  PLATFORMID=linux_riscv64
  ;;
```
MARK：问题：为什么这么写？mips_el什么的为什么后面有后缀呢？
再autoten.sh一下，看报错

```plain
configure: WARNING: You are building 32-bit binaries but the JDK  is 64-bit
configure: error: You should pass the --with-jdk-home option pointing to a (32-bit) JDK
```
## 解决JDK报错问题

搜索You are building 32-bit binaries but the JDK，只有两处 #8544 #8562

继续用刚才修改报错输出的土办法，定位到 #8562

这一部分的代码

```plain
elif test "$cross_compiling" != "yes"; then
         case $CPUNAME in
             AARCH64|AXP|X86_64|HPPA|IA64|POWERPC64|S390X|SPARC64|GODSON64)
                 if test -f "$JAVAINTERPRETER" -a "$JAVAINTERPRETER -version 2>&1 | $GREP -i 64-bit" = "" >/dev/null; then
                     AC_MSG_WARN([You are building 64-bit binaries but the JDK $JAVAINTERPRETER is 32-bit])
                     AC_MSG_ERROR([You should pass the --with-jdk-home option pointing to a 64-bit JDK])
                 fi
                 ;;
             *) # assumption: everything else 32-bit
                 if test -f "$JAVAINTERPRETER" -a "$JAVAINTERPRETER -version 2>&1 | $GREP -i 64-bit" != ""  >/dev/null; then
                     AC_MSG_WARN([02 You are building 32-bit binaries but the JDK $howfound is 64-bit])
                     AC_MSG_ERROR([You should pass the --with-jdk-home option pointing to a (32-bit) JDK])
                 fi
                 ;;
         esac
```
观察上述代码，可以确定的事实有
1. 这不是交叉编译（cross_compiling）
2. 没有找到CPUNAME
3. 以下的判断语句是true的
```plain
test -f "$JAVAINTERPRETER" -a "`$JAVAINTERPRETER -version 2>&1 | $GREP -i 64-bit`" != "" #8561
```
可以看到，如果修改了CPUNAME的判断条件，进入上一个分支，那么这个报错就不会出现
那么添加一个RISCV64进去吧

```plain
AARCH64|AXP|X86_64|HPPA|IA64|POWERPC64|S390X|SPARC64|GODSON64|RISCV64) #8554
```
**./autogen.sh成功通过**
## 其他问题

于波老师在[https://github.com/yuzibo/debian_dev/blob/main/0004-libreoffice-add_support_riscv64.diff](https://github.com/yuzibo/debian_dev/blob/main/0004-libreoffice-add_support_riscv64.diff)里也修改了configure.ac文件的这一部分

```plain
# This is only used in Qt5/Qt6/KF5 checks to determine if /usr/lib64
# paths should be added to library search path. So lets put all 64-bit
# platforms there.
supports_multilib=
case "$host_cpu" in
x86_64 | powerpc64 | powerpc64le | s390x | aarch64 | mips64 | mips64el)
    if test "$SAL_TYPES_SIZEOFLONG" = "8"; then
        supports_multilib="yes"
    fi
    ;;
*)
    ;;
esac
```
虽然现在的环境里是没有/usr/lib64的，但是加上看起来也无伤大雅（只是增加了lib的搜索路径）

# 错误二：gb_UnoApiHeadersTarget_select_variant

```plain
mkdir -p /home/infinity/libreoffice/instdir
/home/infinity/libreoffice/solenv/bin/install-gdb-printers -a /home/infinity/libreoffice/instdir -c
make -j 2  -rs -f /home/infinity/libreoffice/Makefile.gbuild build  
/home/infinity/libreoffice/solenv/gbuild/UnoApiTarget.mk:127: *** gb_UnoApiHeadersTarget_select_variant must be defined by platform.  Stop.
make: *** [Makefile:288: build] Error 2
```
其中，**gb_UnoApiHeadersTarget_select_variant must be defined by platform**是标红加粗的
## 定位错误

查看UnoApiTarget.mk #127

```plain
ifeq ($(origin gb_UnoApiHeadersTarget_select_variant),undefined)
$(eval $(call gb_Output_error,gb_UnoApiHeadersTarget_select_variant must be defined by platform))
endif
```
gb_UnoApiHeadersTarget_select_variant并不是在这里定义的
检查这个变量的定义位置，有六个文件

```plain
com_MSC_class.mk
EMSCRIPTEN_INTEL_GCC.mk
IOS.mk
macosx.mk
solaris.mk
unxgcc.mk
```
这六个文件，都有相同的一段代码
```plain
ifeq ($(DISABLE_DYNLOADING),TRUE)
gb_UnoApiHeadersTarget_select_variant = $(if $(filter udkapi,$(1)),comprehensive,$(2))
else
gb_UnoApiHeadersTarget_select_variant = $(2)
endif
```
尝试在这六段代码中都插入$(call gb_Output_error,shit)来定位错误，并没有发现输出
陷入苦恼……

## 另辟蹊径

不过仔细观察一下这六个文件所在的目录：solenv/gbuild/platform，这个文件夹里存放了大量的基于不同系统、不同架构的.mk文件，是不是和RISCV64缺失有关呢？

观察LINUX_X86_64_GCC.mk等文件，发现都包括了这样一行

```plain
include $(GBUILDDIR)/platform/linux.mk
```
探查linux.mk，里面都有这样一行
```plain
include $(GBUILDDIR)/platform/unxgcc.mk
```
也就是说是这么一个关系：
LINUX_X86_64_GCC --> linux.mk --> unxgcc.mk

上一节里unxgcc.mk并未被执行，那么是不是linux.mk也未被执行呢？那么在linux.mk里也插入$(call gb_Output_error,shit)，make没有输出，说明linux.mk也未被执行

那么试着创建LINUX_RISCV64_GCC.mk，把linux.mk包括进去，linux.mk被执行了！

进一步确认unxgcc.mk里的内容，执行了gb_UnoApiHeadersTarget_select_variant = $(2)，说明$(DISABLE_DYNLOADING) ≠ TRUE

这里有个疑问，LINUX_GODSON64_GCC.mk以及LINUX_POWERPC_GCC.mk里有如下两行代码

```plain
gb_CPUDEFS += -DMIPS64
gb_CPUDEFS += -DPPC
```

我不清楚应该查询什么手册，GCC v11.3.0里也没有检索到DPPC的字样，所以我到底应该查什么手册呢？

至此，gb_UnoApiHeadersTarget_select_variant错误就告一段落了，又有了新的报错 ↓

## 错误三：*no bridge selected for build:*

### bailing out

```plain
/home/infinity/libreoffice//bridges/Module_bridges.mk:27: *** no bridge selected for build: bailing out.  Stop.
make: *** [Makefile:288: build] Error 2
```
## 定位错误

错误出处

```plain
# <root_lo>/bridges/Module_bridges.mk
ifeq (,$(filter build,$(gb_Module_SKIPTARGETS))) 
ifeq ($(strip $(bridges_SELECTED_BRIDGE)),)
$(call gb_Output_error,no bridge selected for build: bailing out) #27
else ifneq ($(words $(bridges_SELECTED_BRIDGE)),1)
$(call gb_Output_error,multiple bridges selected for build: $(bridges_SELECTED_BRIDGE))
endif
endif
```
可以看到，判断了两个条件是否为空，这两个条件是
1. $(filter build,$(gb_Module_SKIPTARGETS))，这个的意思是仅保留gb_Module_SKIPTARGETS变量中的build
2. $(strip $(bridges_SELECTED_BRIDGE))，这个的意思是去掉bridges_SELECTED_BRIDGE的空格
也就是说，gb_Module_SKIPTARGETS中没有build，bridges_SELECTED_BRIDGE是空的，导致no bridge selected for build: bailing out错误，那么应该分头查找这两项

### gb_Module_SKIPTARGETS

gb_Module_SKIPTARGETS定义自文件post_SpeedUpTargets.mk，通过使用gb_Output_error测试，定位到如下代码

```plain
# post_SpeedUpTartgets.mk
ifeq (,$(filter perfcheck,$(MAKECMDGOALS)))
gb_Module_SKIPTARGETS += perfcheck #这一行 #24
else
...
```
即，gb_Module_SKIPTARGETS=perfcheck，这个变量没有build
### bridges_SELECTED_BRIDGE

gb_Module_SKIPTARGETS定义自文件Library_cpp_uno.mk，检索发现如下内容

```plain
...
96,1: bridges_SELECTED_BRIDGE := gcc3_linux_m68k
103,1: bridges_SELECTED_BRIDGE := gcc3_linux_mips
111,1: bridges_SELECTED_BRIDGE := gcc3_linux_mips64
120,1: bridges_SELECTED_BRIDGE := gcc3_linux_powerpc
124,1: bridges_SELECTED_BRIDGE := gcc3_aix_powerpc
...
```
欸，熟悉的不同平台不同架构，拎出mips64部分的代码来
```plain
#Library_cpp_uno.mk
#108
else ifeq ($(CPUNAME),GODSON64)
ifneq ($(filter LINUX,$(OS)),)
bridges_SELECTED_BRIDGE := gcc3_linux_mips64
bridge_asm_objects := call
bridge_noopt_objects := cpp2uno uno2cpp
bridge_exception_objects := except
endif
```
尝试加入以下代码
```plain
#117
else ifeq ($(CPUNAME),RISCV64)
ifneq ($(filter LINUX,$(OS)),)
bridges_SELECTED_BRIDGE := gcc3_linux_riscv64
bridge_asm_objects := call
bridge_noopt_objects := cpp2uno uno2cpp
bridge_exception_objects := except
endif
```

新的报错：

```plain
/home/infinity/libreoffice/bridges/Library_cpp_uno.mk:254: *** No such source file /home/infinity/libreoffice/bridges/source/cpp_uno/gcc3_linux_riscv64/except.cxx.  Stop.
```
## 应该添加什么文件？

查看/home/infinity/libreoffice/bridges/source/cpp_uno/目录

```plain
gcc3_aix_powerpc/    gcc3_linux_mips/       gcc3_macosx_x86-64/
gcc3_ios/            gcc3_linux_mips64/     gcc3_solaris_intel/
gcc3_linux_aarch64/  gcc3_linux_powerpc/    gcc3_solaris_sparc/
gcc3_linux_alpha/    gcc3_linux_powerpc64/  gcc3_wasm/
gcc3_linux_arm/      gcc3_linux_s390/       msvc_shared/
gcc3_linux_hppa/     gcc3_linux_s390x/      msvc_win32_arm64/
gcc3_linux_ia64/     gcc3_linux_sparc/      msvc_win32_intel/
gcc3_linux_intel/    gcc3_linux_sparc64/    msvc_win32_x86-64/
gcc3_linux_m68k/     gcc3_linux_x86-64/     shared/
```
然后查看gcc3_linux_mips64**文件夹**：
```plain
call.hxx  call.s  cpp2uno.cxx  except.cxx  share.hxx  uno2cpp.cxx
```
联想到上文
```plain
#Library_cpp_uno.mk
#108
bridges_SELECTED_BRIDGE := gcc3_linux_mips64
bridge_asm_objects := call
bridge_noopt_objects := cpp2uno uno2cpp
bridge_exception_objects := except
```
可以猜测，bridges_SELECTED_BRIDGE指定的是文件夹，而后面三个则指定了具体的文件，那么应该尝试将mips64的文件夹复制一份为gcc3_linux_riscv64
core竟然开始编译了！

关于加速编译过程，可以参看“小技巧”一文

# 错误四：firebird3

错误日志[https://github.com/Sakura286/TmpShare/blob/main/20220615-172432-lo.log](https://github.com/Sakura286/TmpShare/blob/main/20220615-172432-lo.log)

firebird3是*种数据库，*



检索firebird官网发现只提供了x86与ARM架构的程序；另一方面libreoffice对firebird有替代品（我又忘了来源了），那么在“最小子集化”编译的时候暂时禁掉无妨

autogen.sh --help，并在产生的结果检索firebird，找到了--disable-firebird-sdbc参数，试着autogen添加这个参数，然后推进到错误五

# 错误五：jvmfwk

错误日志[https://github.com/Sakura286/TmpShare/blob/main/2206156-140242-lo.log](https://github.com/Sakura286/TmpShare/blob/main/2206156-140242-lo.log)

基本上都是下面两个文件的错误：

```plain
<lo_root>/jvmfwk/plugins/sunmajor/pluginlib/otherjre.cxx
<lo_root>/jvmfwk/plugins/sunmajor/pluginlib/sunjre
```

定位错误
部分错误

```plain
In file included from /home/infinity/libreoffice/jvmfwk/plugins/sunmajor/pluginlib/otherjre.hxx:23,
                 from /home/infinity/libreoffice/jvmfwk/plugins/sunmajor/pluginlib/otherjre.cxx:21:
/home/infinity/libreoffice/jvmfwk/inc/vendorbase.hxx:79:2: error: #error unknown platform
   79 | #error unknown platform
      |  ^~~~~
```
otherjre.cxx的第21行是这样
```plain
#include "otherjre.hxx"
```
所以继续找otherjre.hxx的第23行：
```plain
#include <vendorbase.hxx>
```




继续找<lo_root>/jvmfwk/inc/vendorbase.hxx第79行
```plain
...
#define JFW_PLUGIN_ARCH "parisc"
#elif defined AXP
#define JFW_PLUGIN_ARCH "alpha"
#elif defined AARCH64
#define JFW_PLUGIN_ARCH "aarch64"
#else // SPARC, INTEL, POWERPC, MIPS, MIPS64, ARM, IA64, M68K, HPPA, ALPHA
#error unknown platform
#endif
...
```

在#62插入

```plain
#elif defined RISCV64
#define JFW_PLUGIN_ARCH "riscv64"
```
然后就通过了……真莫名其妙啊，炼丹似的
# 错误六：cpp_uno

错误日志[https://github.com/Sakura286/TmpShare/blob/main/20220616-145237-lo.log](https://github.com/Sakura286/TmpShare/blob/main/20220616-145237-lo.log)

使用于波老师的patch

手动看了一下和之前的修改的区别

1. call.s改动比较多，主要是把变量名与指令改成了riscv64相同的
2. cpp2uno.cxx两处改动

```cpp
# cpp2uno.cxx
# 46
//#ifndef ANDROID
//#include <sys/sysmips.h>
//#endif

# cppuno.cxx
# 610
#ifdef ANDROID
  (void) bptr;
  (void) eptr;
```

3. uno2cpp.cxx改动了变量名
改动后，出现了新的错误

[https://github.com/Sakura286/TmpShare/blob/main/20220616-162240-lo.log](https://github.com/Sakura286/TmpShare/blob/main/20220616-162240-lo.log)

[https://github.com/Sakura286/TmpShare/blob/main/20220616-163412-lo.log](https://github.com/Sakura286/TmpShare/blob/main/20220616-163412-lo.log)

## 定位错误

错误内容的开头

```log
/home/infinity/libreoffice/bridges/source/cpp_uno/gcc3_linux_riscv64/call.s: Assembler messages:
/home/infinity/libreoffice/bridges/source/cpp_uno/gcc3_linux_riscv64/call.s:61: Error: illegal operands `mv a1,0(ra)'
/home/infinity/libreoffice/bridges/source/cpp_uno/gcc3_linux_riscv64/call.s:82: Error: unrecognized opcode `b .Lfinish'
/tmp/ccmCpgbR.s: Error: open CFI at the end of file; missing .cfi_endproc directive
```

看起来是汇编那边出了问题

# 错误七

错误内容

```log
Illegal instruction
make[1]: *** [/home/infinity/libreoffice/solenv/gbuild/Gallery.mk:57: /home/infinity/libreoffice/workdir/Gallery/backgrounds.done] Error 1
make[1]: *** Waiting for unfinished jobs....
Illegal instruction
make[1]: *** [/home/infinity/libreoffice/solenv/gbuild/Gallery.mk:57: /home/infinity/libreoffice/workdir/Gallery/sounds.done] Error 1
make: *** [Makefile:288: build] Error 2
```

使用`--with-galleries=no`选项
